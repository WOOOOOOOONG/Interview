# 저장소 설명
https://gyoogle.dev/blog/interview/
<br/>(해당 저장소에 정리가 너무나 잘 되어 있기 때문에, '위 저장소 내용+alpha' 또는 몇가지를 내가 원하는 표현으로 바꾸어 기록하는 용도의 저장소)

# 운영체제
## 인터럽트
프로그램 실행 중 예기치 못한 상황이 발생한 경우에 실행 중인 프로그램을 중단하고, 해당 상황에 대한 처리가 우선적으로 필요함을 CPU에게 알리는 것을 의미.
인터럽트는 크게 3가지로 구분되는데, 내부 인터럽트는 오버플로우 등 잘못된 명령 또는 데이터를 사용할 경우 발생하고, 외부 인터럽트는 입출력 장치나 전원 등의 외부적인 요인, 소트프웨어 인터럽트는 특정 프로그램 처리 중에 별도 요청에 따라 발생한 인터럽트이다.
내, 외부 인터럽트는 CPU의 하드웨어 신호에 의해 발생하는 인터럽트이며, 소프트웨어 인터럽트는 명령어 수행에 의해 발생.
### 처리 순서
1. 인터럽트 요청 신호
2. 프로그램 실행 중단
3. 현재 실행 중인 프로그램 복귀 주소를 Stack에 저장
4. 문제 파악 등 인터럽트 처리 루틴을 실행
5. 문제 해결을 위한 인터럽트 서비스 루틴 실행
6. 상태 복구가 중단된 프로그램 재실행
### 우선순위
1. 전원 이상
2. 기계 이상
3. 외부 신호
4. 입/출력
5. 프로그램 검사
6. SVC(SuperVisor Call)

## 스케줄링
언제 어떤 프로세스에 CPU를 할당하는지 결정하는 작업을 CPU 스케줄링이라 하며, 종류로는 크게 선점/비선점 스케줄링이 존재한다.
### 비선점 스케줄링
프로세스가 CPU 점유 시 이를 뺏을 수 없는 방식
FCFS(First Come First Served) : 큐에 도착한 순서로 CPU를 할당
SJF(Shortest Job First) : 수행시간이 가장 짧다고 판단되는 작업을 먼저 실행
HRN(Hightest Response-ratio Next) : 우선순위( (대기시간+실행시간) / 실행시간 )를 계산하여 우선순위가 높은 작업을 먼저 실행

### 선점 스케줄링
프로세스가 실행 중이더라도 운영체제가 강제로 뺏을 수 있는 방식
우선순위 스케줄링(Priority Sheduling) : 우선 순위를 동적, 정적으로 부여해 순위가 높은 순서대로 처리하는 스케줄링으로, 기아(Starvation)라고 하는 우선 순위가 낮은 프로세스를 무한정으로 기다리는 경우가 발생할 수 있다.
RR(Round Robin) : CPU 할당 시간을 각 프로세스에 동일하게 부여하여 정해진 시간만큼만 작업 후 넘어가는 방법
멀티레벨 큐(MultiLevel Queue) : 어떤 프로세스이냐에 따라, 여러 종류의 그룹으로 나눈 뒤 여러개의 큐에 다양한 알고리즘 적용하는 방법

### Sync, Async 전송의 차이점
- Sync(Synchronous)
미리 정해진 양 만큼의 문자열을 하나로 묶어 한 번에 전송하는 방법이며, 송신한 데이터를 수식받는 측에서 정확한 내용을 수신받기 위해 타이밍을 일치시키는 것을 동기식 전송이라고 한다.
전송 효율이 높다는 장점이 있고, 수신측에서 문자를 조립해 비트를 계산하는 기억 장치가 필요해 가격 증가
Async(Asynchronous)
에디터 내 동기 신호를 포함해 데이터를 전송하는 방식으로, 타이밍을 맞추지 않고 문자 단위로 구분해 전송하는 방식이다.
시작 비트와 정지 비트 사이 간격이 가변적이기 때문에 불규칙적이거나 짧은 데이터 전송에 적합하며, 시작 비트와 정지 비트 전송으로 인한 추가적인 오버헤드를 갖는다.

# 네트워크
### DNS RR(Round Robin) 방식
DNS 서버 구성 방식 중 하나로, 도메인에 대한 IP 요청 쿼리를 보내면 Round Robin 방식으로 IP를 반환하는 것이다.
즉, DNS 서버에 대한 Round Robin 형식으로 구성할 경우에는 부하에 대한 걱정이 필요 없기에 로드 벨런서 또한 필요가 없어진다.(자동으로 시간에 따라 스케쥴링이 변화하여)

### 웹 통신 전체적인 흐름(주소창에 URL 입력 시 발생)
1. 사용자가 웹 브라우저를 통해 URL 입력
2. URL의 도메인 네임을 DNS 서버에서 검색하여 IP 찾은 후 URL 정보와 함께 사용자에게 전달
3. 전달받은 내용을 통해 HTTP 요청 메시지 생성하여 TCP로 서버로 전송
4. 서버가 클라이언트의 요청을 받고 응답을 전송
5. 사용자가 홈페이지 이용

# DB
### Key
기본 키는 모든 행 데이터가 고유하게 식별되는 테이블의 해당 열입니다. 테이블의 모든 행에는 기본 키가 있어야하며 두 행은 동일한 기본 키를 가질 수 없습니다. 기본 키 값은 절대로 null이거나 수정하거나 업데이트 할 수 없습니다. 복합 키는 열 세트가 테이블의 모든 행을 고유하게 식별하는 후보 키의 양식입니다.
유니크 키
Unique 키는 유일성을 가지기 위해 설정해 놓은 키로 중복이 되는 것을 방지합니다. Primary 키는 오직 하나만 생성할 수 있지만, Unique키는 여러개 생성이 가능합니다. Primary키의 경우 NULL 값을 허용하지 않지만, Unique 키는 NULL 값을 허용합니다.

### DELETE vs TRUNCATE vs DROP
'DELETE' 연산을 실행 한 후 손실 된 데이터를 검색하기 위해 COMMIT 및 ROLLBACK 문을 수행 할 수 있습니다.
'TRUNCATE' 조작을 실행 한 후 손실 된 데이터를 검색하기 위해 COMMIT 및 ROLLBACK 문을 수행 할 수 없습니다.
'DROP' 명령은 기본 키 / 외래 키와 같은 테이블 또는 키를 삭제하는 데 사용됩니다.

### Join
두 개 이상의 테이블이나 데이터베이스를 연결하여 데이터를 검색하는 방법입니다.
Inner Join 은 2개 이상의 테이블에서 교집합만을 추출
Left Join 은 2개 이상의 테이블에서 from에 해당하는 부분을 추출
Right Join 은 2개 이상의 테이블에서 from과 join하는 테이블에 해당하는 부분을 추출
Outer Join 은 아웃터 조인 또는 풀 조인이라고 말함, 2개 이상의 테이블에서 모든 테이블에 해당하는 부분을 추출

### SQL Injection
SQL injection은 악의적으로 SQL문을 실행해서 비정상적으로 데이터베이스를 조작하는 공격 방법

### Transaction
데이터베이스의 DML(Data Manipulation Language), 즉 삽입(INSERT), 갱신(UPDATE), 삭제(DELETE)와 관련된 논리적인 작업을 말하며, DML 실행과 동시성 제어를 위한 중요한 개념이다.
관계형 데이터베이스 시스템은 데이터를 처리할 때 트랜잭션을 통해 정상 종료나 사용자 프로세스 실패나 시스템 실패와 같은 비정상 종료에 대해 데이터의 신뢰성과 일관성을 보장한다.
즉, 데이터베이스의 데이터 무결성이 보장되는 상태에서 DML 작업을 완수하기 위한 기본 작업 단위이다.
4개 특성 : 원자성, 일관성, 고립성, 지속성
트랜잭션 제어어 : 커밋, 롤백

### Statement vs PreparedStatement
Prepared Statement
쿼리실행 계획 분석과 컴파일이 완료되어서 DBMS의 캐시에 준비되어있는 쿼리를 사용하는 것. 즉 위에서의 4단계 중 parse 과정을 생략하고 나머지 3단계만 실행한다.
장점 : SQL 처리가 빠르며, SQL이 반복적일 때 효과적이다.
단점 : 쿼리 오류 발생 시 분석이 어렵다. 바인드 변수가 일부 위치에서만 사용되기 때문에 동적 쿼리 작성이 어렵다.
Statement
prepared statement와 다르게 4단계를 매번 실행하여 결과 값을 리턴한다.
장점 : 동적 쿼리 실행 가능, 쿼리 실행문 직접 확인 가능
단점 : 반복 실행의 경우 불리, SQLI 공격 가능성

### RDBMS vs NoSQL
RDBMS는 모든 데이터를 2차원 테이블 형태로 표현합니다.
장점 : 스키마에 맞춰 데이터를 관리하기 때문에 데이터의 정합성을 보장할 수 있다.
단점 : 시스템이 커질 수록 쿼리가 복잡해지고 성능이 저하되며 Scale-out이 어렵다(Scale-up만 가능)
NoSQL(Not Only SQL)은 RDBMS와 반대로 데이터간의 관계를 정의하지 않고, 스키마가 없어 좀 더 자유롭게 데이터를 관리할 수 있으며, 컬렉션이라는 형태로 데이터를 관리합니다.
장점 : 스키마 없이 Key-Value 형태로 데이터를 관리해 자유롭게 데이터를 관리할 수 있다.
데이터 분산이 용이하여 성능 향상을 위한 scale-up 뿐만아닌 scale-out 또한 가능하다.
단점 : 데이터 중복이 발생할 수 있고, 중복된 데이터가 변경될 경우 수정을 모든 컬렉션에서 수행해야 한다.
스키마가 존재하지 않기에 명확한 데이터 구조를 보장하지 않아 데이터 구조 결정이 어려울 수 있다.
💡그렇다면 RDBMS와 NoSQL은 어느 경우에 적합한가요?
RDBMS는  또한 중복된 데이터가 없어(데이터 무결성) 변경이 용이하기 때문에 관계를 맺고 있는 데이터가 자주 변경이 이루어지는 시스템에 적합합니다.
데이터 구조가 명확하고, 변경 될 여지가 없으며 스키마가 중요한 경우 사용하는 것이 좋습니다.
NoSQL은  또한 단점에서도 명확하듯 데이터 중복이 발생할 수 있으며 중복된 데이터가 변경될 시 모든 컬렉션에서 수정해야 하기 때문에 Update가 많이 이루어지지 않는 시스템에 좋으며, Scale-out이 가능하다는 장점을 활용해 막대한 데이터를 저장해야 해서 DB를 Scale-out 해야 되는 시스템에 적합합니다.
정확한 데이터 구조를 알 수 없고 데이터가 변경/확장 될 수 있는 경우 사용하는 것이 좋습니다.

### NoSQL
### Stored Procedure

# Web
### Browser 동작 방식
### HTTP Request Method
### REST API
### 쿠키 & 세션
### 크로스 브라우징
### Vue.js & React
### CSRF & XSS
